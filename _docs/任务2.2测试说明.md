# 任务2.2测试说明文档

## 📋 测试概览

**任务名称：** 追捕者玩法与游戏循环
**版本：** V1.0
**测试日期：** 2025年
**测试人员：** Clare

---

## 🎯 功能清单

### 1. 追捕者玩法

| 功能项 | 脚本文件 | 说明 |
|-------|---------|------|
| ✅ 可控移动 | HunterController.ts | 复用摇杆逻辑，速度115% |
| ✅ 攻击按钮 | HunterController.ts + HunterUI.ts | 2米范围，1秒冷却 |
| ✅ 踩碎木板 | HunterController.ts + HunterUI.ts | 2.5米范围，立即销毁 |

### 2. 游戏循环

| 功能项 | 脚本文件 | 说明 |
|-------|---------|------|
| ✅ 5分钟倒计时 | GameManager.ts | 实时更新 |
| ✅ 矿石统计 | GameManager.ts + Ore.ts | 拾取时自动计数 |
| ✅ 逃脱统计 | GameManager.ts + ExitZone.ts | 进入区域触发 |
| ✅ 淘汰统计 | GameManager.ts + CharacterState.ts | 状态监听自动计数 |
| ✅ 胜负判定 | GameManager.ts | 3种结局逻辑 |
| ✅ UI显示 | GameUI.ts | 倒计时+统计+结果 |

---

## 🧪 测试步骤

### 阶段1：场景配置（Cocos Creator编辑器）

#### 1.1 创建GameManager节点

1. 在场景根节点创建空节点，命名为 `GameManager`
2. 添加组件：`GameManager`
3. 配置参数：
   - `gameDuration`: 300（5分钟）
   - `survivorsToWin`: 3
   - `eliminationsToWin`: 3
   - `autoStartGame`: ✅ 勾选（自动开始）

#### 1.2 配置追捕者节点

假设已有红色Cube节点命名为 `Hunter`：

1. 添加组件：`HunterController`
2. 绑定引用：
   - `joystick`: 拖拽虚拟摇杆节点
   - `cameraNode`: 拖拽摄像机节点
3. 配置参数：
   - `moveSpeed`: 5.75（115%速度）
   - `attackRange`: 2.0
   - `attackCooldown`: 1.0
   - `boardBreakRange`: 2.5
4. 确保已有 `Hunter` 组件（之前任务已添加）
5. 确保已有 `BoxCollider`（IsTrigger=✅）

#### 1.3 创建GameUI节点

1. 在Canvas下创建节点 `GameUI`
2. 添加组件：`GameUI`
3. 创建子节点（使用Cocos Creator的UI组件）：

**倒计时文字：**
```
节点名: TimerLabel
组件: Label
文字: "时间: 05:00"
字号: 32
颜色: 白色
位置: 屏幕顶部居中
```

**矿石统计：**
```
节点名: OreLabel
组件: Label
文字: "矿石: 0"
位置: 左上角
```

**逃脱统计：**
```
节点名: EscapedLabel
组件: Label
文字: "逃脱: 0/3"
位置: 左上角（矿石下方）
```

**淘汰统计：**
```
节点名: EliminatedLabel
组件: Label
文字: "淘汰: 0/3"
位置: 左上角（逃脱下方）
```

**游戏结束面板：**
```
节点名: GameOverPanel
组件: Sprite（半透明黑色背景）
大小: 覆盖全屏
初始状态: Active = ❌（隐藏）

子节点:
  - GameOverLabel (Label)
    文字: "游戏结束"
    字号: 64
    颜色: 白色
    对齐: 居中
```

4. 绑定GameUI组件引用：
   - `timerLabel`: TimerLabel
   - `oreLabel`: OreLabel
   - `escapedLabel`: EscapedLabel
   - `eliminatedLabel`: EliminatedLabel
   - `gameOverPanel`: GameOverPanel
   - `gameOverLabel`: GameOverLabel

#### 1.4 创建HunterUI节点

1. 在Canvas下创建节点 `HunterUI`
2. 添加组件：`HunterUI`
3. 创建攻击按钮：

```
节点名: AttackButton
组件: Button + Sprite
大小: 120x60
位置: 屏幕右下角（摇杆右侧）
初始状态: Active = ❌（隐藏）

子节点:
  - AttackLabel (Label)
    文字: "攻击"
    字号: 24
    颜色: 白色
```

4. 创建踩碎木板按钮：

```
节点名: BreakBoardButton
组件: Button + Sprite
大小: 120x60
位置: 攻击按钮上方
初始状态: Active = ❌（隐藏）

子节点:
  - BreakBoardLabel (Label)
    文字: "踩碎木板"
    字号: 24
    颜色: 白色
```

5. 绑定HunterUI组件引用：
   - `attackButton`: AttackButton
   - `attackLabel`: AttackLabel
   - `breakBoardButton`: BreakBoardButton
   - `breakBoardLabel`: BreakBoardLabel
   - `hunterController`: Hunter节点的HunterController组件

#### 1.5 创建逃脱区域

1. 创建3D节点，命名为 `ExitZone`
2. 添加组件：
   - `BoxCollider`（IsTrigger=✅，调整大小）
   - `ExitZone`
3. 配置参数：
   - `exitPrompt`: "逃脱区域"
   - `requireOreCount`: 0（不需要矿石）
   - `destroySurvivorOnExit`: ❌（保留节点用于调试）
4. 放置在地图边缘（逃生者能到达的位置）

---

### 阶段2：功能测试

#### 测试1：追捕者移动（115%速度）

**步骤：**
1. 运行游戏
2. 使用摇杆控制追捕者移动
3. 观察移动速度

**预期结果：**
- ✅ 追捕者响应摇杆输入
- ✅ 移动速度明显快于逃生者（5.75 vs 5.0）
- ✅ 旋转平滑，面向移动方向

**通过标准：** 移动流畅，速度差异明显

---

#### 测试2：攻击功能

**步骤：**
1. 控制追捕者靠近逃生者（2米内）
2. 观察HunterUI是否显示"攻击"按钮
3. 点击攻击按钮
4. 观察逃生者状态

**预期结果：**
- ✅ 靠近时显示"攻击 [逃生者名称]"按钮
- ✅ 点击后逃生者被抓捕（状态变为CAUGHT）
- ✅ 逃生者跟随追捕者移动（成为子节点）
- ✅ 攻击按钮进入1秒冷却（显示"冷却中 0%~100%"）
- ✅ 离开范围后按钮隐藏

**通过标准：** 抓捕逻辑正常，冷却正确

---

#### 测试3：踩碎木板

**步骤：**
1. 让逃生者推倒一块木板
2. 控制追捕者靠近倒下的木板（2.5米内）
3. 观察HunterUI是否显示"踩碎木板"按钮
4. 点击按钮

**预期结果：**
- ✅ 靠近倒下木板时显示"踩碎木板"按钮
- ✅ 点击后木板节点隐藏（`active=false`）
- ✅ 控制台输出：`[Board] 木板被踩碎`
- ✅ 按钮消失

**通过标准：** 木板正确销毁

---

#### 测试4：游戏倒计时

**步骤：**
1. 游戏开始后观察TimerLabel
2. 等待1分钟

**预期结果：**
- ✅ 初始显示"时间: 05:00"
- ✅ 每秒递减："04:59" → "04:58" → ...
- ✅ 格式正确（MM:SS，补零）
- ✅ 剩余<1分钟时文字变红色

**通过标准：** 倒计时准确，UI更新流畅

---

#### 测试5：矿石统计

**步骤：**
1. 控制逃生者拾取3个矿石
2. 观察OreLabel

**预期结果：**
- ✅ 每次拾取后数字+1
- ✅ 显示："矿石: 0" → "矿石: 1" → "矿石: 2" → "矿石: 3"
- ✅ 控制台输出：`[GameManager] 矿石被拾取，当前数量：X`

**通过标准：** 统计准确，UI同步

---

#### 测试6：逃脱统计

**步骤：**
1. 控制逃生者进入ExitZone区域
2. 观察EscapedLabel

**预期结果：**
- ✅ 进入区域后数字+1
- ✅ 显示："逃脱: 0/3" → "逃脱: 1/3"
- ✅ 逃生者节点隐藏（`active=false`）
- ✅ 控制台输出：`[ExitZone] [逃生者] 成功逃脱！`
- ✅ 同一逃生者不能重复计数

**通过标准：** 逃脱触发正常，防重复计数

---

#### 测试7：淘汰统计

**步骤：**
1. 让追捕者抓捕逃生者3次（每次挂笼子等超时）
2. 观察EliminatedLabel

**预期结果：**
- ✅ 第3次挂起后立即淘汰（任务2.1已修复）
- ✅ 淘汰后数字+1："淘汰: 0/3" → "淘汰: 1/3"
- ✅ 达到3人时文字变红色
- ✅ 控制台输出：`[GameManager] 逃生者被淘汰，当前数量：X`

**通过标准：** 淘汰触发正常，UI变色

---

#### 测试8：胜负判定 - 追捕者胜利（淘汰≥3人）

**步骤：**
1. 让追捕者淘汰3个逃生者
2. 观察游戏结果

**预期结果：**
- ✅ 第3人淘汰瞬间游戏结束
- ✅ 显示GameOverPanel
- ✅ 文字："追捕者胜利！"（红色）
- ✅ 控制台输出：`[GameManager] 游戏结束！结果：hunter_win`

**通过标准：** 胜利条件正确，UI显示正确

---

#### 测试9：胜负判定 - 逃生者胜利（逃脱≥3人）

**步骤：**
1. 让3个逃生者进入ExitZone
2. 观察游戏结果

**预期结果：**
- ✅ 第3人逃脱瞬间游戏结束
- ✅ 显示GameOverPanel
- ✅ 文字："逃生者胜利！"（绿色）
- ✅ 控制台输出：`[GameManager] 游戏结束！结果：survivor_win`

**通过标准：** 胜利条件正确，UI显示正确

---

#### 测试10：胜负判定 - 时间到（多种情况）

**情况A：时间到且逃脱<2人 → 追捕者胜利**

**步骤：**
1. 使用调试命令：`GameManager.getInstance().setTimeRemaining(5)` 设置剩余5秒
2. 等待倒计时归零，确保逃脱人数<2

**预期结果：**
- ✅ 时间归零瞬间游戏结束
- ✅ 显示："追捕者胜利！"（红色）

---

**情况B：时间到且逃脱=2人 → 平局**

**步骤：**
1. 让2个逃生者逃脱
2. 设置剩余5秒
3. 等待倒计时归零

**预期结果：**
- ✅ 时间归零瞬间游戏结束
- ✅ 显示："平局！"（黄色）
- ✅ 控制台输出：`[GameManager] 游戏结束！结果：draw`

---

**情况C：时间到且逃脱≥3人 → 逃生者胜利**

**步骤：**
1. 让3个逃生者逃脱（应该在逃脱时就结束了）

**预期结果：**
- ✅ 不会等到时间到，第3人逃脱时就胜利

**通过标准：** 3种时间到情况判定正确

---

### 阶段3：集成测试

#### 完整游戏流程测试

**剧本1：追捕者胜利路线**

```
1. 游戏开始（倒计时5:00）
2. 逃生者A拾取2个矿石（矿石:2）
3. 追捕者攻击逃生者A，抓捕成功
4. 追捕者将A挂笼子（淘汰:0→1，等超时）
5. 重复3次，淘汰3人
6. 游戏结束："追捕者胜利！"
```

**剧本2：逃生者胜利路线**

```
1. 游戏开始
2. 逃生者A推倒木板
3. 追捕者踩碎木板
4. 逃生者B、C、D拾取矿石并逃脱
5. 第3人逃脱时游戏结束："逃生者胜利！"
```

**剧本3：平局路线**

```
1. 游戏开始
2. 2个逃生者逃脱（逃脱:2/3）
3. 1个逃生者被淘汰（淘汰:1/3）
4. 剩余逃生者躲避追捕者
5. 5分钟倒计时结束
6. 游戏结束："平局！"
```

**剧本4：混合功能测试**

```
1. 游戏开始
2. 逃生者A拾取矿石（矿石:1）
3. 逃生者B被抓捕并挂笼子
4. 逃生者C救援B成功
5. 追捕者打断救援（测试救援中断）
6. 逃生者D推倒木板
7. 追捕者踩碎木板
8. 继续进行直到游戏结束
```

---

## 🐛 常见问题排查

### 问题1：攻击按钮不显示

**可能原因：**
- HunterUI未绑定HunterController
- 攻击范围太小
- 逃生者不是正常状态

**解决方案：**
1. 检查HunterUI的hunterController引用
2. 调大attackRange（如改为3.0）
3. 确保逃生者状态为NORMAL

---

### 问题2：游戏不自动开始

**可能原因：**
- GameManager的autoStartGame未勾选
- GameManager节点未激活

**解决方案：**
1. 勾选autoStartGame
2. 或调用：`GameManager.getInstance().startGame()`

---

### 问题3：倒计时不更新

**可能原因：**
- GameUI未绑定timerLabel
- GameManager未找到

**解决方案：**
1. 检查GameUI的timerLabel引用
2. 确保场景中只有一个GameManager

---

### 问题4：踩碎木板无效

**可能原因：**
- 木板状态不是DOWN
- 检测范围太小

**解决方案：**
1. 确保木板已被推倒（状态=DOWN）
2. 调大boardBreakRange（如改为3.0）

---

### 问题5：逃脱不计数

**可能原因：**
- ExitZone的BoxCollider未设置为Trigger
- 逃生者状态不是NORMAL

**解决方案：**
1. 勾选BoxCollider的IsTrigger
2. 确保逃生者状态为NORMAL

---

## 📊 测试报告模板

```markdown
## 测试报告

**测试日期：** YYYY-MM-DD
**测试人员：** [姓名]
**测试版本：** V1.0

### 测试结果统计

| 测试项 | 通过 | 失败 | 备注 |
|-------|------|------|------|
| 追捕者移动 | ✅ | - | - |
| 攻击功能 | ✅ | - | - |
| 踩碎木板 | ✅ | - | - |
| 游戏倒计时 | ✅ | - | - |
| 矿石统计 | ✅ | - | - |
| 逃脱统计 | ✅ | - | - |
| 淘汰统计 | ✅ | - | - |
| 追捕者胜利判定 | ✅ | - | - |
| 逃生者胜利判定 | ✅ | - | - |
| 平局判定 | ✅ | - | - |

### 发现的问题

1. [问题描述]
   - 严重程度：高/中/低
   - 复现步骤：...
   - 预期结果：...
   - 实际结果：...

### 总体评价

[测试总结...]
```

---

## 🚀 快速验证命令

在浏览器控制台使用以下命令快速测试：

```javascript
// 获取GameManager
const gm = window['cc'].director.getScene().getComponentInChildren(window['cc']._decorator.js.getClassByName('GameManager'));

// 设置剩余时间为10秒
gm.setTimeRemaining(10);

// 模拟逃脱
gm.debugEscape(1);

// 模拟淘汰
gm.debugEliminate(1);

// 查看游戏信息
console.log(gm.getGameInfo());

// 重新开始游戏
gm.restartGame();
```

---

## ✅ 验收标准

所有测试项必须通过，具体要求：

1. **追捕者玩法：** 移动、攻击、踩碎木板功能完整且流畅
2. **游戏循环：** 倒计时准确，统计实时更新
3. **胜负判定：** 5种结局逻辑全部正确
4. **UI显示：** 所有UI元素正确显示和更新
5. **无关键Bug：** 无崩溃、无逻辑错误
6. **性能良好：** 帧率稳定≥30fps

**测试通过后，任务2.2正式交付！** 🎉
